# --- ESO Vault Kubernetes auth integration ---------------------------------
APP_NS          ?= playground
K8S_CTX         ?= $(K8S_CTX)
VAULT_ADDR      ?= $${VAULT_ADDR}
VAULT_NAMESPACE ?= admin
ESO_ROLE        ?= eso-$(APP_NS)-$(ENV)
POLICY_NAME     ?= eso-$(APP_NS)-$(ENV)

# What secret path you want ESO to read
VAULT_SECRET_PATH ?= $(APP_NS)/cicd-helloworld-example-$(ENV)


absPathMakefile := $(abspath $(lastword $(MAKEFILE_LIST)))
wd              := $(shell dirname $(absPathMakefile))
WD              := $(wd)/
# BIN_DIR         ?= ../bin



ENVS            := int qas prd
ENV             ?= qas
VAULT_ENGINE    ?= kv-$${ENV}

#-namespace=admin -mount="kv-qas" "playground/cicd-helloworld-example-vault"

# --- Phony Targets ---
.PHONY: all env_tokens vault_k8s_auth_enable vault_k8s_auth_config vault_policy vault_role vault_eso_bootstrap \
  token_lookup  put_ns-app-secret_key-value get_ns-app-secret_key\
 list_ns-app-secret_keys create_kvs poli set_policy $(ENVS:$$=$$_poli) FORCE



# --- Main Entry Points ---
all: create_kvs  set_policy env_tokens

poli: $(ENVS:$$=$$_poli)

FORCE:

%_poli: test FORCE
	@echo "Generating and writing policy for: $*"
	ENV=$* envsubst < policy-tmpl.hcl > policy-$*.hcl
	ENV=$* bao policy write kv2-$*-admin "./policy-$*.hcl" >/dev/null 2>&1 || exit 1
	ENV=$* VAULT_TOKEN=$${VAULT_TOKEN_ROOT} bao token create -format=json -policy="kv2-$*-admin" > vault-$*.token

set_policy: test
	@if [ -f "./policy.hcl" ]; then \
		echo bao policy write kv2-admin "./policy.hcl" >/dev/null 2>&1 || exit 1; \
	fi
	$(MAKE) int_poli
	$(MAKE) qas_poli
	$(MAKE) prd_poli


# What secret path you want ESO to read
VAULT_SECRET_PATH ?= $(APP_NS)/$${APP_NAME}-$(ENV)

.PHONY: vault_k8s_auth_enable vault_k8s_auth_config vault_policy vault_role vault_eso_bootstrap

vault_k8s_auth_enable:
	@bao auth enable -namespace=$(VAULT_NAMESPACE) kubernetes >/dev/null 2>&1 || true

vault_k8s_auth_config: vault_k8s_auth_enable
	@echo "Configuring Vault Kubernetes auth using token reviewer SA (external-secrets/vault-token-reviewer)"
	@K8S_HOST="$$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}')"; \
	kubectl -n external-secrets create token vault-token-reviewer --duration=24h > /tmp/reviewer.jwt; \
	kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[0].cluster.certificate-authority-data}' | base64 -d > /tmp/ca.crt; \
	bao write -namespace=$(VAULT_NAMESPACE) auth/kubernetes/config \
	  kubernetes_host="$$K8S_HOST" \
	  kubernetes_ca_cert=@/tmp/ca.crt \
	  token_reviewer_jwt=@/tmp/reviewer.jwt >/dev/null

vault_policy:
	@echo "Writing Vault policy $(POLICY_NAME) for kv-$(ENV)/data/$(VAULT_SECRET_PATH)"
	@cat > /tmp/$(POLICY_NAME).hcl <<HCL \
		path "kv-$(ENV)/data/$(VAULT_SECRET_PATH)" {\
  		capabilities = ["read"] \
		}\
	HCL;

	@bao policy write -namespace=$(VAULT_NAMESPACE) $(POLICY_NAME) /tmp/$(POLICY_NAME).hcl >/dev/null

vault_role: vault_policy
	@echo "Writing Vault k8s role $(ESO_ROLE) bound to SA eso-vault in ns $(APP_NS)"
	@bao write -namespace=$(VAULT_NAMESPACE) auth/kubernetes/role/$(ESO_ROLE) \
	  bound_service_account_names=eso-vault \
	  bound_service_account_namespaces=$(APP_NS) \
	  policies=$(POLICY_NAME) \
	  ttl=1h >/dev/null

# One-shot: enable + config + role/policy
vault_eso_bootstrap: vault_k8s_auth_config vault_role
	@echo "âœ… Vault Kubernetes auth ready for ESO role=$(ESO_ROLE)"







#####



token_lookup:
	@bao token lookup -namespace=admin $${VAULT_TOKEN}




env_token:
	@cat vault-$(ENV).token | jq -r .auth.client_token

# --- KV Store Management (Bash Loop) ---
create_kvs:
	for env in $(ENVS); do \
		echo "Ensuring KV v2 engine is enabled at: kv-$$env"; \
		if ! bao secrets list | grep -q "^kv-$$env/"; then \
			bao secrets enable -path=kv-$$env kv-v2; \
		fi; \
		echo "KV store 'kv-$$env' is ready."; \
	done


# --- Helpers ---

test:
	@echo "Testing connection to $${VAULT_HOSTNAME}:$${VAULT_PORT}"
	bash -c '( > /dev/tcp/$${VAULT_HOSTNAME}/$${VAULT_PORT} || exit )'


list_ns-app-secret_keys:
	@echo "$(APP_NAME) has thes keys in $(VAULT_ADDR) using $(VAULT_ENGINE):"
	@bao kv get -format=json -mount=$(VAULT_ENGINE) $(NAMESPACE)/$(APP_NAME) | jq -r '.data.data | keys[]'


get_ns-app-secret_key:
	@echo "$(APP_NAME) key: $(SECRET_KEY) in $(VAULT_ADDR) using $(VAULT_ENGINE):"
	@SECRET_KEY=$${SECRET_KEY} bao kv get -format=json -mount=$(VAULT_ENGINE) $(NAMESPACE)/$(APP_NAME) | \
  jq -r '.data.data["$(SECRET_KEY)"]'

put_ns-app-secret_key-value:
	@echo "$(APP_NAME) key: $${KEY} willl be put in $(VAULT_ADDR) using $(VAULT_ENGINE):"
	@KEY=$${KEY}VALUE=$${VALUE} SECRET=$${SECRET}  bao kv put -mount=$(VAULT_ENGINE) $(NAMESPACE)/$(APP_NAME)/$(SECRET) $(KEY)=$(VALUE)

#bao kv get -format=json -mount=$(VAULT_ENGINE) $(NAMESPACE)/$(APP_NAME)

# refresh manual
#kubectl -n playground annotate externalsecret playground-cicd-helloworld-example-vault-qas   externalsecrets.external-secrets.io/refresh-now="$(date +%s)" --overwrite

